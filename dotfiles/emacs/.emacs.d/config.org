#+TITLE: Emacs Configuration
#+AUTHOR: Guilherme Azzi

# Export all elisp snippets inside this file:
#+PROPERTY: header-args:emacs-lisp :tangle yes


* Table of Contents :TOC:
- [[#credits][Credits]]
- [[#initial-setup-and-compilation][Initial Setup and Compilation]]
  - [[#packaging-system][Packaging System]]
  - [[#the-use-package-macro][The =use-package= Macro]]
  - [[#compiling-the-configuration][Compiling the Configuration]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
- [[#user-interface][User Interface]]
  - [[#mode-line][Mode Line]]
  - [[#colours-and-fonts][Colours and Fonts]]
  - [[#better-defaults][Better Defaults]]
  - [[#editing-keybindings][Editing Keybindings]]
  - [[#better-completion-and-search][Better Completion and Search]]
  - [[#better-window-navigation][Better Window Navigation]]
  - [[#auto-completion][Auto-Completion]]
  - [[#line-wrapping][Line Wrapping]]
  - [[#removing-trailing-whitespace][Removing Trailing Whitespace]]
  - [[#smart-handling-of-parentheses][Smart Handling of Parentheses]]
- [[#org-mode-and-getting-things-done][Org Mode and Getting Things Done]]
  - [[#org-mode][Org Mode]]
  - [[#synchronisation-with-google-calendar][Synchronisation with Google Calendar]]
  - [[#gettings-things-done][Gettings Things Done]]
- [[#languages][Languages]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#latex][LaTeX]]
- [[#features][Features]]
  - [[#version-control][Version Control]]
  - [[#directory-browser][Directory Browser]]
  - [[#spell-and-grammar-checking][Spell and Grammar Checking]]
  - [[#shellbash][Shell/Bash]]
  - [[#on-the-fly-syntax-and-error-checking][On-The-Fly Syntax and Error Checking]]

* Credits

This configuration is heavily based on the work of others, in particular the following.

  - [[https://github.com/larstvei/dot-emacs]]


* Initial Setup and Compilation
** Packaging System

We initialize the packaging system, adding some common package
repositories.  Installed packages will /not/ be enabled by default.
Their loading will be described along the rest of this configuration.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC

** The =use-package= Macro

We also ensure that the =use-package= macro is installed and loaded.  It
provides many facilities for loading packages, including: loading packages
lazily, loading custom bits of configuration along with the packages and
auto-installing any missing packages.  For more instructions check its [[https://github.com/jwiegley/use-package/blob/master/README.md][readme]]
file.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))
#+END_SRC

Note that =use-package= will often setup autoloads to avoid loading too many
packages at startup.  This will be done when at least one of the following
options is used: =:bind=, =:bind-keymap=, =:mode=, =:interpreter=, =:commands=
or =:defer=.  Most of the calls to =use-package= should have at least one of
these options to make Emacs startup run quickly.

For configuration related to the package, consider using the options listed
below.  Function definitions, however, should be written under =:preface= so
that they are pre-compiled with the configuration file.

  - =:config= runs arbitrary elisp code after the package is loaded
  - =:custom= sets custom variables after the package is loaded
  - =:custom-face= sets custom faces after the package is loaded

If a package depends on others, use the =:after= option to avoid loading it
before other packages.

** Compiling the Configuration

Since the configuration is written in =org-mode= with tangled elisp code, it
must be compiled to an elisp file.  This compilation should be done whenever
this file is saved, which we guarantee using an =after-save-hook=.

#+BEGIN_SRC emacs-lisp
  (defvar me/config-org-file
    (expand-file-name "config.org" user-emacs-directory)
    "Org file containing the emacs configuration.")

  (defvar me/config-elisp-file
    (expand-file-name "config.el" user-emacs-directory)
    "Location where the compiled emacs configuration should be written.

  This file will receive the elisp code extracted from
  'me/config-org-file' and should be loaded on startup.")

  (defun me/compile-tangled-config (compiled-file)
    "Move the 'COMPILED-FILE' to 'me/config-elisp-file' and ensure
  it is byte-compiled."
    (unless (equal compiled-file me/config-org-file)
      (rename-file compiled-file me/config-elisp-file t))
    (byte-compile-file me/config-elisp-file))

  (defun me/compile-config-from-org-on-save ()
    "If the current buffer has 'me/config-org-file' open, compile
  the tangled elisp in the file, save it to 'me/config-elisp-file'
  and load it."
    (when (equal (buffer-file-name) me/config-org-file)
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
        (me/compile-tangled-config
         (car (org-babel-tangle nil me/config-elisp-file "emacs-lisp")))
        (load-file me/config-elisp-file))))

  (add-hook 'after-save-hook 'me/compile-config-from-org-on-save)
#+END_SRC

We also provide shortcut commands for reloading the config.

#+BEGIN_SRC emacs-lisp
  (defun compile-and-reload-config ()
    "Recompile and reload the config from 'me/config-org-file'"
    (interactive)
    (me/compile-tangled-config
     (car (org-babel-tangle-file me/config-org-file me/config-elisp-file "emacs-lisp")))
    (load-file me/config-elisp-file))

  (defun reload-config ()
    "Reload the config from 'me/config-org-file'"
    (interactive)
    (load-file me/config-elisp-file))
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs.  It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself.  By default, changes in the customization will be
automatically detected and appended at the end of the configuration file,
=init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up.  The
following tells Emacs to add extra code in another file that would be then
loaded, if existing.

#+BEGIN_SRC emacs-lisp
  (setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=.  This is also where you want your API tokens to live.

Note that the file will be loaded /after/ the complete configuration.

#+BEGIN_SRC emacs-lisp
  (defun me/load-secrets (loaded-file-name)
    (when (eq loaded-file-name me/config-elisp-file)
      (let ((secret-el (expand-file-name ".secret.el" user-emacs-directory)))
        (when (file-exists-p secret-el)
          (load secret-el)
          (message "Loaded .secret.el")))))

  (run-at-time "1 millisec" nil 'me/load-secrets me/config-elisp-file)
  (add-hook 'after-load-functions 'me/load-secrets)
#+END_SRC


* User Interface
** Mode Line

The mode line can be made prettier (and easier to understand).

#+BEGIN_SRC emacs-lisp
   (use-package powerline
     :ensure t
     :config
     (powerline-center-theme)
     :custom
      (powerline-default-separator 'slant)
      (powerline-default-separator-dir '(left . right))
      (powerline-display-buffer-size nil)
     :custom-face
      (mode-line ((t (:background "grey18" :box (:line-width 1 :color "#44475a")))))
      (mode-line-inactive ((t (:background "grey18" :foreground "#f8f8f2" :box (:line-width 1 :color "#373844")))))
      (powerline-active1 ((t (:background "#cc863d" :foreground "grey15"))))
      (powerline-active2 ((t (:background "#cc863d" :foreground "grey15"))))
      (powerline-inactive1 ((t (:background "grey25"))))
      (powerline-inactive2 ((t (:background "grey25" :foreground "#f8f8f2")))))
#+END_SRC

We can also improve how modes are displayed.

#+BEGIN_SRC emacs-lisp
  (use-package delight :ensure t)
#+END_SRC

** Colours and Fonts

The face for italic text is underlined when the font does not support
slant by default.  I don't like it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'italic nil :underline nil)
#+END_SRC

Load and set =dracula-theme=.

#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :ensure t
    :demand t
    :config
    (load-theme 'dracula t))
#+END_SRC

When running with a GUI, use the Fira Code font.  In order to simulate
its ligatures, we use the [[https://github.com/tonsky/FiraCode/wiki/Emacs-instructions][following workaround]].

#+BEGIN_SRC emacs-lisp
  (when (window-system)
    (set-frame-font "Fira Code")

    (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
                   (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
                   (36 . ".\\(?:>\\)")
                   (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
                   (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                   (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
                   (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
                   (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                   (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
                   (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                   (48 . ".\\(?:x[a-zA-Z]\\)")
                   (58 . ".\\(?:::\\|[:=]\\)")
                   (59 . ".\\(?:;;\\|;\\)")
                   (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
                   (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                   (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                   (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
                   (91 . ".\\(?:]\\)")
                   (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                   (94 . ".\\(?:=\\)")
                   (119 . ".\\(?:ww\\)")
                   (123 . ".\\(?:-\\)")
                   (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                   (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
                   )
                 ))
      (dolist (char-regexp alist)
        (set-char-table-range composition-function-table (car char-regexp)
                              `([,(cdr char-regexp) 0 font-shape-gstring])))))
#+END_SRC

** Better Defaults

Some UI elements are rather invasive and require a mouse.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)                           ; Disable the cursor blinking
    (menu-bar-mode 0)                               ; Disable the menu bar
    (tool-bar-mode 0))                              ; Disable the tool bar
#+END_SRC

Here are some options that I consider better defaults.

#+BEGIN_SRC emacs-lisp
  (setq-default
   auto-window-vscroll nil                          ; Lighten vertical scroll
   confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   delete-by-moving-to-trash t                      ; Delete files to trash
   display-time-default-load-average nil            ; Don't display load average
   display-time-format "%H:%M"                      ; Format the time string
   fill-column 80                                   ; Set width for automatic line breaks
   help-window-select t                             ; Focus new help windows when opened
   indent-tabs-mode nil                             ; Stop using tabs to indent
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   left-margin-width 1 right-margin-width 1         ; Add left and right margins
   recenter-positions '(5 top bottom)               ; Set re-centering positions
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   scroll-margin 10                                 ; Add a margin when scrolling vertically
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   tab-width 4                                      ; Set width for tabs
   uniquify-buffer-name-style 'forward              ; Uniquify buffer names
   window-combination-resize t                      ; Resize windows proportionally
   x-stretch-cursor t)                              ; Stretch cursor to the glyph width
  (delete-selection-mode 1)                         ; Replace region when inserting text
  (display-time-mode 1)                             ; Enable time in the mode-line
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  (global-subword-mode 1)                           ; Iterate through CamelCase words
  (fringe-mode 0)                                   ; Disable fringes
  (global-display-line-numbers-mode 1)              ; Display line numbers beside text
  (line-number-mode 0)                              ; Omit line numbers in the status bar
  (column-number-mode 1)                            ; Display column numbers in the status bar
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Editing Keybindings

I dislike the inconsistency between =C-w= in Emacs and bash.  Set =C-w= to
behave like bash, killing backward to the beginning of a word.  Also make =C-k=
kill the region, if active---otherwise the line is killed, as in the default
behaviour.  Note that some modes will have their own variants of =kill-line=
mapped to =C-k=, and those modes should call =me/bind-kill-region-or-line= in
their configuration.

#+BEGIN_SRC emacs-lisp
  (defmacro me/bind-kill-region-or-line (key-map kill-line kill-region)
    "Define and bind a function that kills the region, if active, or the line.
  The defined function will interactively call 'KILL-REGION' when
  the region is currently active, or 'KILL-LINE' otherwise.  It
  will also be bound to 'C-k' in the given 'KEY-MAP'."
    (let ((kill-region-or-line
           (intern (format "%s-or-%s" kill-region kill-line))))
      `(progn
         (defun ,kill-region-or-line ()
           ,(format
             "Kill the region if active, otherwise kill the current line.
  See also '%s' and '%s'."
             kill-region
             kill-line)
           (interactive)
           (if (region-active-p)
               (call-interactively ',kill-region)
             (call-interactively ',kill-line)))
         (define-key ,key-map (kbd "C-k") ',kill-region-or-line))))

  (global-set-key (kbd "C-w") 'backward-kill-word)
  (me/bind-kill-region-or-line global-map kill-line kill-region)
#+END_SRC

Undoing and redoing in Emacs is inconsistent with almost every other graphical
program.  Set =C-z= to undo and =C-S-z= to redo.  Also use the =undo-tree= mode
to have better handling of the undo history.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t
    :ensure t
    :delight undo-tree-mode nil
    :commands global-undo-tree-mode
    :bind
    (:map undo-tree-map
     ("C-_" . nil)
     ("C-/" . nil)
     ("C-?" . nil)
     ("M-_" . nil)
     ("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Better Completion and Search

Having a good completion mechanism can make life a lot easier.  The [[https://oremacs.com/swiper][=ivy=]]
package provides such a mechanism, which we couple with the fuzzy matching
provided by =flx=.

#+BEGIN_QUOTE
[[https://github.com/abo-abo/swiper/blob/master/README.md#ivy][abo-abo]]

Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

When running =ivy-mode=, pressing =<return>= will use the currently selected
candidate, while =C-<return>= will use the current input instead of the current
candidate.

#+BEGIN_SRC emacs-lisp
  (use-package flx :ensure t)

  (use-package ivy
    :ensure t
    :delight ivy-mode nil
    :commands ivy-mode ivy-resume ivy-immediate-done
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy)))
    :custom-face
    (ivy-minibuffer-match-face-2 ((t (:background "#777777" :weight bold))))
    (ivy-minibuffer-match-face-3 ((t (:background "#777777" :weight bold))))
    (ivy-minibuffer-match-face-4 ((t (:background "#777777" :weight bold))))
    :bind
    (("C-c C-r" . 'ivy-resume)
     :map ivy-mode-map
     ("C-<return>" . 'ivy-immediate-done)))
#+END_SRC

The =counsel= package provides ivy-based alternatives to some commonly used
builtin functionality, and =swiper= an alternative search command.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("<f1> f" . 'counsel-describe-function)
     ("<f1> v" . 'counsel-describe-variable)
     ("<f1> l" . 'counsel-find-library)
     ("<f2> i" . 'counsel-info-lookup-symbol)
     ("C-c u" . 'counsel-unicode-char)))

  (use-package swiper
    :ensure t
    :bind
    ("C-s" . 'swiper))
#+END_SRC

** Better Window Navigation

I like to navigate between windows with =C-x <arrow>=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x <left>") 'windmove-left)
  (global-set-key (kbd "C-x <right>") 'windmove-right)
  (global-set-key (kbd "C-x <down>") 'windmove-down)
  (global-set-key (kbd "C-x <up>") 'windmove-up)
#+END_SRC

I also disable the usual window navigation so I get used to arrows.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x o") nil)
#+END_SRC

** Auto-Completion

Auto-completion at point.  Display a small pop-in containing the candidates.
Use fuzzy matching provided by the =flx= package.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight company-mode nil
    :commands global-company-mode
    :config
    (setq-default
     company-idle-delay .2
     company-minimum-prefix-length 1
     company-require-match nil
     company-tooltip-align-annotations t))

  (use-package company-flx
    :ensure t
    :after company flx
    :delight company-flx-mode nil
    :commands company-flx-mode)

  (global-company-mode 1)
  (company-flx-mode 1)
#+END_SRC

** Line Wrapping

When lines are too long, they will be soft-wrapped using =visual-line-mode=.
Since this mode ignores indentation, we use =adaptive-wrap= to correct it.

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
    :ensure t
    :commands adaptive-wrap-prefix-mode
    :hook
    ('visual-line-mode . 'adaptive-wrap-prefix-mode))

  (global-visual-line-mode 1)
#+END_SRC
** Removing Trailing Whitespace

By default, trailing whitespace is removed whenever a file is saved.  This can
be avoided by setting the file-local variable
=delete-trailing-whitespace-on-save= to =nil=.

#+BEGIN_SRC emacs-lisp
  (defvar delete-trailing-whitespace-on-save t
    "When non-nil, trailing whitespace is deleted before saving the file.")

  (make-variable-buffer-local 'delete-trailing-whitespace-on-save)

  (defun me/delete-trailing-whitespace-before-save ()
    "Remove trailing whitespace if 'remove-trailing-whitespace-on-save' is non-nil."
    (when delete-trailing-whitespace-on-save
      (delete-trailing-whitespace)))

  (add-hook 'before-save-hook 'me/delete-trailing-whitespace-before-save)
#+END_SRC
** Smart Handling of Parentheses

The [[https://github.com/Fuco1/smartparens][=smartparens=]] package makes it easier to deal with parentheses and
delimiters in general.  It will automatically insert the matching pair (e.g.,
when you type ='('=, it will insert =')'=), wrap the region inside parentheses,
among others.  Use the command =sp-cheat-sheet= to see the available commands
with examples.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens-config
    :ensure smartparens   ; The package name differs from the provided feature
    :commands smartparens-mode)
#+END_SRC

The automatic use of =smartparens= should be ensured by setting up hooks for the
appropriate modes, under the appropriate entry of the [[Languages][Languages section]].


* Org Mode and Getting Things Done
** Org Mode

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

When setting up =org-mode=, we change a number of its settings.  First, we make
sure buffer names are surrounded by asterisks.  We also correct the binding of
=C-k= as prescribed in [[Editing Keybindings]].  Finally, set a few settings and
ensure [[Spell and Grammar Checking][spell checking]] is turned on.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :delight org-mode "Org"
    :commands org-babel-tangle-file
    :preface
    (defun me/org-src-buffer-name (org-buffer-name language)
      "Construct the buffer name for a source editing buffer. See
  `org-src--construct-edit-buffer-name'."
      (format "*%s*" org-buffer-name))
    :config
    (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer-name)
    (me/bind-kill-region-or-line org-mode-map org-kill-line kill-region)
    (setq
     org-startup-truncated nil        ; Truncated lines not needed because of visual-line-mode
     org-log-done 'time               ; Record completion time for tasks
     org-hide-leading-stars t         ; Only show a single star for each org heading
     org-return-follows-link t        ; Use <return> to follow links
     org-enforce-todo-dependencies t  ; Make sure subtasks are completed before supertask
     org-ellipsis " ⤵")               ; Use a prettier character for folded sections
    :hook
    (org-mode . flyspell-mode))       ; Ensure spell
#+END_SRC

Display in the header-line the heading of the node at the top of the window.
This avoids confusion when there is some text at the top of the window, and its
heading wouldn't be visible.

#+BEGIN_SRC emacs-lisp
  (use-package org-sticky-header
    :ensure t
    :after org
    :config
    (setq-default
     org-sticky-header-full-path 'full
     org-sticky-header-outline-path-separator " › "
     org-sticky-header-prefix "› "
     org-sticky-header-heading-star "")
    :hook
    (org-mode . org-sticky-header-mode))
#+END_SRC

Tired of having to manually update your tables of contents?  This package will
maintain a TOC at the first heading that has a =:TOC:= tag.

#+BEGIN_SRC emacs-lisp
  (use-package toc-org
    :ensure t
    :after org
    :hook
    (org-mode . toc-org-enable))
#+END_SRC

We can make =org-mode= prettier by showing actual bullets.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :after org
    :delight org-bullets-mode nil
    :hook
    (org-mode . org-bullets-mode))
#+END_SRC

** Synchronisation with Google Calendar

We can use =org-gcal= to synchronise =org-mode= files with google calendar.

#+BEGIN_SRC emacs-lisp
  (use-package org-gcal
    :ensure t
    :hook
    ((org-agenda-mode . org-gcal-sync)
     (org-capture-after-finalize-hook . org-gcal-sync)))
#+END_SRC

In order to communicate with google you should properly set a client ID, client
secrets and calendar IDs in =~/.emacs.d/.secret.el=.  This is done as follows,
and more information on getting the client ID and secrets as well as calendar
IDs is given in the [[https://github.com/myuhe/org-gcal.el/blob/master/README.org#installation][=org-gcal= readme]].

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-gcal-client-id "oauth 2.0 client ID"
        org-gcal-client-secret "client secret"
        org-gcal-file-alist '(("username@gmail.com" . "path/to/gcal.org")))

  (add-to-list org-agenda-files "path/to/gcal.org")
#+END_SRC

** Gettings Things Done

I am trying to adopt GTD, implemented using org-mode and following
some workflows suggested [[https://orgmode.org/worg/org-gtd-etc.html][online]].

*** File Structure

Most of the files related to GTD are kept in the directory =~/gtd=,
which includes the following.

 - =inbox.org= contains [[Capture][captured]] stuff to process later;
 - =projects.org= contains the current projects;
 - =someday.org= contains ideas and tasks for the future that should
   be periodically checked, but not all the time.
 - =tickler.org= contains entries that should be seen at a particular
   point in the future, recorded as a [[orgmode.org/manual/Timestamps.html][timestamp]].
 - =references= contains reference documents, to which projects should
   link using =org-store-link= from Dired buffers.
 - =*.org_archive= files contain done projects, tasks and other items
   that need no longer be reviewed.

#+BEGIN_SRC emacs-lisp
  (defvar me/gtd-directory "~/gtd"
    "Root directory where the GTD files are located")

  (defvar me/gtd-inbox-file (expand-file-name "inbox.org" me/gtd-directory)
    "Org file where new tasks and ideas are collected")

  (defvar me/gtd-projects-file (expand-file-name "projects.org" me/gtd-directory)
    "Org file where projects are listed and planned")

  (defvar me/gtd-someday-file (expand-file-name "someday.org" me/gtd-directory)
    "Org file for suspended ideas and tasks")

  (defvar me/gtd-tickler-file (expand-file-name "tickler.org" me/gtd-directory)
    "Org file where reminders are set for particular points in the future")
#+END_SRC


*** Steps
**** Capture

The first part of the GTD system is capturing /everything/---every
thought, task, idea---into an inbox to be later processed.  Adding a
new entry to the inbox should be super easy and frictionless, so there
is no incentive to avoid it, and it also doesn't interrupt the task at
hand.

In Emacs this we use the [[https://orgmode.org/manual/Capture.html][capture]] feature of =org-mode=, which can be
activated with =C-c c=, to add entries to =inbox.org=.  There may be
other inboxes in one's life: e-mail, messaging apps, a physical
inbox...

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat me/gtd-directory "/inbox.org"))
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

You can add links to the captured entries with =C-c C-l=, which make it easier
to access related material.  If you are linking to something that was accessed
inside Emacs, you can use =C-c l= to copy a link to its location, then =C-c C-l=
to paste it.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC

In particular we set up some templates for easily adding a new task or
a new reminder for a particular point in the future.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
	'(("t" "To-do [inbox]" entry
	   (file+headline me/gtd-inbox-file "Tasks")
	   "* TODO %i%?")
	  ("n" "Note [inbox]" entry
	   (file+headline me/gtd-inbox-file "Notes"))
	  ("r" "Reminder" entry
	   (file+headline me/gtd-ticker-file "Tickler")
	   "* %i%? \n %U")))
#+END_SRC

**** Clarify and Organize

Every inbox should be periodically checked.  The meaning of each entry
should be checked, and it should either be solved or moved to the
appropriate place, according to the standard GTD workflow:

[[https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/GTDcanonical.png/1280px-GTDcanonical.png]]

In order to easily move entries from the =inbox.org= to the
appropriate place, we can [[https://orgmode.org/manual/Refile-and-copy.html#Refile-and-copy][refile]] entries with =C-c C-w=.  Common
targets include any project, the tickler or the someday/maybe list.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
	'((me/gtd-projects-file :maxlevel . 3)
	  (me/gtd-someday-file :maxlevel . 2)
	  (me/gtd-tickler-file :maxlevel . 2)))
#+END_SRC

Tasks may be in one of the following states.
  - =NEXT=: incomplete and should be done in the near future
  - =TODO=: incomplete, but need not be done in the near future
  - =WAITING=: incomplete, but there's nothing to be done for now
  - =DONE=: completed succesfully
  - =CANCELLED=: no longer relevant

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"
           "NEXT(n)"
           "WAITING(w)"
           "|"
           "DONE(d)"
           "CANCELLED(c)")))
#+END_SRC

When filing tasks and other notes, they can be annotated with tags,
which may denote a few different things.

 - Regular categories, like =:work:= or =:health:=
 - People involved in the task, like =:dad:= or =:sabine:=
 - GTD contexts starting with an =@=, such as =@home=, =@office=,
   =@phone=, =@email=, =@errands=, =@laptop=.

Tasks and notes can also [[orgmode.org/manual/Deadlines-and-scheduling.html][be scheduled or have deadlines]], including
repeating schedules and items.  You should avoid adding dates to
anything that isn't an appointment, a hard deadline or a tickler
entry.  The decision of what to do next should be taken based on the
current context and next tasks, not based on artificial scheduling
decisions made with possibly outdated information.

**** Reflect

The lists should be reviewed frequently, which help keeps the big
picture of your life in your head.  Of course, reviewing every entry
of every list is quite time consuming, and shouldn't be done all the
time.  A good approach is reviewing all lists once a week---the
so-called weekly review.  When deciding what to do next, you should
first review your calendar/agenda to check appointments and deadlines,
then check the =NEXT= actions, filtered by your current context.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
    (list
      me/gtd-projects-file
      me/gtd-inbox-file
      me/gtd-tickler-file))
 #+END_SRC

For day-to-day use of the GTD system, you should use both [[https://orgmode.org/manual/Sparse-trees.html][sparse trees]]
and [[https://orgmode.org/manual/Agenda-views.html#Agenda-views][agenda views]].  Each Org document can be turned into a sparse tree
with =C-c /=, which will use some dispatcher to show little, selected
information about each item in the document.

In order to easily open the GTD files, we provide the following commands.

#+BEGIN_SRC emacs-lisp
  (defun open-gtd-inbox ()
    (interactive)
    (find-file me/gtd-inbox-file))

  (defun open-gtd-projects ()
    (interactive)
    (find-file me/gtd-projects-file))

  (defun open-gtd-tickler ()
    (interactive)
    (find-file me/gtd-tickler-file))

  (defun open-gtd-someday ()
    (interactive)
    (find-file me/gtd-someday-file))
#+END_SRC

[[https://orgmode.org/manual/Agenda-views.html#Agenda-views][Agenda views]] provide a summarized overview of the calendar/agenda and
pending tasks from multiple files.  [[orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom agenda commands]] can be
defined to, e.g., show only the next actions, filter them by context.

I use =C-c a= to access the agenda dispatcher, which then allows me to choose
among the many agenda views.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

A custom agenda view available with =C-c a n= will display an agenda for the
current week as well as all next actions.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("n" "Agenda for the week and next actions"
           ((agenda)
            (todo "NEXT")))))
#+END_SRC

**** Engage

Do stuff!  Complete the next actions!


* Languages
** Emacs Lisp

Lisp should use the [[Smart Handling of Parentheses][=smartparens-mode=]].

#+BEGIN_SRC emacs-lisp
  (add-hook 'elisp-mode 'smartparens-mode)
#+END_SRC

** LaTeX

Note that the =auctex= tool must be installed externally for this to work.  Some
options are modified, such as a compilation to PDF by default.  Since I often
split LaTeX projects into multiple files, I also force =TeX-mode= to always ask
for a master file by setting =TeX-master=.  I also add support for using a
=Makefile= to compile LaTeX projects.

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :defer t
    :ensure auctex
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-PDF-mode t)
    (setq-default TeX-master nil)
    (add-to-list 'TeX-command-list
                 '("Make" "make" TeX-run-compile nil t)))
#+END_SRC

When using =LaTeX-mode=, we want to automatically turn on the following
features: [[Spell and Grammar Checking][spell checking]], [[Smart Handling of Parentheses][smart parentheses]] (use =C-q "= to insert regular
quotes) synchronisation of the point with the document viewer
(=TeX-source-correlate-mode=), easy insertion of mathematical symbols
(=LaTeX-math-mode=) and easier management of labels, references and citations
(=reftex-mode=).

Moreover, a compilation error overview should be available with =C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (use-package latex
    :defer t
    :after tex
    :bind
    (:map LaTeX-mode-map
          ("C-c C-o" . TeX-error-overview))
    :config
    (use-package smartparens-latex :after smartparens)
    :hook
    ((LaTeX-mode . flyspell-mode)
     (LaTeX-mode . smartparens-mode)
     (LaTeX-mode . LaTeX-math-mode)
     (LaTeX-mode . TeX-source-correlate-mode)
     (LaTeX-mode . reftex-mode)))
#+END_SRC

We also enable auto-completion of bibtex keys using [[https://github.com/gbgar/company-bibtex][=company-bibtex=]].  Its
completion function is modified to allow for fuzzy matching, and to show more
readable annotations.

#+BEGIN_SRC emacs-lisp
  (use-package company-bibtex
    :ensure t
    :after latex company
    :functions company-grab company-begin-backend company-bibtex-candidates
    :commands me/enable-company-bibtex company-bibtex
    :config
    (defalias 'company-bibtex 'me/company-bibtex)
    :hook
    (LaTeX-mode . me/enable-company-bibtex)
    :preface
    (defun me/enable-company-bibtex ()
      (interactive)
      (add-to-list 'company-backends 'company-bibtex))
    (defun me/company-bibtex (command &optional arg &rest ignored)
      "`company-mode' completion backend for bibtex key completion.
  This backend activates for citation styles used by `pandoc-mode' (@),
  `latex-mode' (\cite{}), and `org-mode' (ebib:), and reads from a
  bibliography file or files specified in `company-bibtex-bibliography'.
  COMMAND, ARG, and IGNORED are used by `company-mode'."

      (interactive (list 'interactive))
      (cl-case command
        (interactive (company-begin-backend 'company-bibtex))
        (prefix (cond ((derived-mode-p 'latex-mode)
                       (company-grab (format "%s\\(%s,\\)*\\(%s\\)"
                                             company-bibtex-latex-citation-regex
                                             company-bibtex-key-regex
                                             company-bibtex-key-regex)
                                     2))
                      ((derived-mode-p 'org-mode)
                       (company-grab (format "%s\\(%s,\\)*\\(%s\\)"
                                             company-bibtex-org-citation-regex
                                             company-bibtex-key-regex
                                             company-bibtex-key-regex)
                                     2))
                      ((derived-mode-p 'markdown-mode)
                       (company-grab (format "%s\\(%s\\)"
                                             company-bibtex-pandoc-citation-regex
                                             company-bibtex-key-regex)
                                     1))
                      ))
        (candidates (company-bibtex-candidates arg))
        (annotation (me/company-bibtex-get-annotation arg))
        (meta (me/company-bibtex-get-metadata arg))
        (duplicates t)
        (no-cache t)))

    (defun me/company-bibtex-get-annotation (candidate)
      "Get annotation from CANDIDATE, which is its title."
      (let ((prefix-length 0))
        (format " | %s"
                (replace-regexp-in-string "{\\|}" ""
                                          (get-text-property prefix-length :title candidate)))))

    (defun me/company-bibtex-get-metadata (candidate)
      "Get metadata from CANDIDATE."
      (let ((prefix-length 0))
        (let ((title
               (get-text-property prefix-length :title candidate))
              (authors
               (replace-regexp-in-string "[[:space:]]*\n[[:space:]]*" " "
                                         (get-text-property prefix-length :author candidate))))
          (replace-regexp-in-string "{\\|}" ""
                                    (format "Title: %s\nAuthors: %s" title authors))))))
#+END_SRC


* Features
** Version Control

[[https://magit.vc/][Magit]] provides git facilities directily withing Emacs.  It is honestly the best
git frontend I have ever used.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Jonas Bernoulli]]

Magit is an interface to the version control system [[https://git-scm.com/][Git]], implemented as an [[https://www.gnu.org/software/emacs][Emacs]]
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.
[[https://magit.vc/about.html][(more)]]
#+END_QUOTE

The magit status buffer can be opened with =C-x g=.  Most of the functionality
of magit is available from there, as documented in the [[https://magit.vc/manual/magit.html#Getting-Started][magit manual]].  We also
ensure that =magit= does [[Better Completion and Search][better completion and search]] than the default.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ("C-x g" . 'magit-status)
    :config
    (setq magit-completing-read-function 'ivy-completing-read))
#+END_SRC
** Directory Browser

The Emacs directory browser =dired= usually opens far too many buffers.  We
avoid this by remapping =<return>= to /replace/ the current buffer when
following a link, and =C-<return>= to open a new buffer.

We also ensure that =dired= hides details by default and shows directories
before other files, besides a couple other settings.

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :commands dired-find-file dired-find-alternate-file
    :bind
    (:map dired-mode-map
     ("<return>" . 'dired-find-alternate-file)
     ("C-<return>" . 'dired-find-file))
    :hook (dired-mode-hook . dired-hide-details-mode)
    :config
    (setq
     dired-auto-revert-buffer t                   ; Reload directories when changed
     dired-dwim-target t                          ; Intelligently guess targets for copy/rename
     dired-hide-details-hide-symlink-targets nil  ; Never hide symlink targets
     dired-listing-switches "-alh --group-directories-first"))
#+END_SRC
** Spell and Grammar Checking

Commands related to spell and grammar checking are prefixed with =C-S-l=.

The underlying spell checker is preferably Aspell, but alternatively Hunspell.
Note that Aspell personal dictionaries are stored in =~/.aspell.LANG.pws=, where
=LANG= is the two-letter code.  I use British English most of the time.

#+BEGIN_SRC emacs-lisp
  (cond
   ((executable-find "aspell")
    (setq ispell-program-name "aspell"))
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")))

  (setq ispell-dictionary "en_GB")
#+END_SRC

The =flyspell-mode= will highlight misspelled words.  Then =C-S-l c= can be used
to correct them.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :bind
    (:map flyspell-mode-map
          ("C-S-l c" . 'ispell-word))
    :hook (text-mode-hook . flyspell-mode))
#+END_SRC

** Shell/Bash

A bash shell can be run inside Emacs with the =ansi-term= command.  A shortcut
for opening a bash is =C-x t=.

#+BEGIN_SRC emacs-lisp
  (defun term-bash ()
    (interactive)
    (ansi-term "bash"))

  (global-set-key (kbd "C-x t") 'term-bash)
#+END_SRC
** On-The-Fly Syntax and Error Checking

We can use =flycheck= for running linters, compilers or similar tools
automatically, and highlighting any errors detected directly in the source code.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :demand t
    :commands global-flycheck-mode
    :init (global-flycheck-mode))
#+END_SRC
