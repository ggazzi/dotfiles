#+TITLE: Emacs Configuration
#+AUTHOR: Guilherme Azzi

# Export all elisp snippets inside this file:
#+PROPERTY: header-args:emacs-lisp :tangle yes


* Table of Contents :TOC:
- [[#credits][Credits]]
- [[#initial-setup-and-compilation][Initial Setup and Compilation]]
  - [[#packaging-system][Packaging System]]
  - [[#the-use-package-macro][The =use-package= Macro]]
  - [[#compiling-the-configuration][Compiling the Configuration]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
- [[#user-interface][User Interface]]
  - [[#mode-line][Mode Line]]
  - [[#colours-and-fonts][Colours and Fonts]]
  - [[#better-defaults][Better Defaults]]
  - [[#editing-keybindings][Editing Keybindings]]
  - [[#better-completion-and-search][Better Completion and Search]]
  - [[#better-window-navigation][Better Window Navigation]]
  - [[#auto-completion][Auto-Completion]]
  - [[#recursive-minibuffers][Recursive Minibuffers]]
  - [[#line-wrapping][Line Wrapping]]
  - [[#removing-trailing-whitespace][Removing Trailing Whitespace]]
  - [[#smart-handling-of-parentheses][Smart Handling of Parentheses]]
- [[#languages][Languages]]
  - [[#emacs-lisp][Emacs Lisp]]

* Credits

This configuration is heavily based on the work of others, in particular the following.

  - [[https://github.com/larstvei/dot-emacs]]


* Initial Setup and Compilation
** Packaging System

We initialize the packaging system, adding some common package
repositories.  Installed packages will /not/ be enabled by default.
Their loading will be described along the rest of this configuration.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)

  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC

** The =use-package= Macro

We also ensure that the =use-package= macro is installed and loaded.  It
provides many facilities for loading packages, including: loading packages
lazily, loading custom bits of configuration along with the packages and
auto-installing any missing packages.  For more instructions check its [[https://github.com/jwiegley/use-package/blob/master/README.md][readme]]
file.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))
#+END_SRC

Note that =use-package= will often setup autoloads to avoid loading too many
packages at startup.  This will be done when at least one of the following
options is used: =:bind=, =:bind-keymap=, =:mode=, =:interpreter=, =:commands=
or =:defer=.  Most of the calls to =use-package= should have at least one of
these options to make Emacs startup run quickly.

For configuration related to the package, consider using the options listed
below.  Function definitions, however, should be written under =:preface= so
that they are pre-compiled with the configuration file.

  - =:config= runs arbitrary elisp code after the package is loaded
  - =:custom= sets custom variables after the package is loaded
  - =:custom-face= sets custom faces after the package is loaded

If a package depends on others, use the =:after= option to avoid loading it
before other packages.

** Compiling the Configuration

Since the configuration is written in =org-mode= with tangled elisp code, it
must be compiled to an elisp file.  This compilation should be done whenever
this file is saved, which we guarantee using an =after-save-hook=.

#+BEGIN_SRC emacs-lisp
  (defvar me/config-org-file
    (expand-file-name "config.org" user-emacs-directory)
    "Org file containing the emacs configuration.")

  (defvar me/config-elisp-file
    (expand-file-name "config.el" user-emacs-directory)
    "Location where the compiled emacs configuration should be written.

  This file will receive the elisp code extracted from
  'me/config-org-file' and should be loaded on startup.")

  (defun me/compile-tangled-config (compiled-file)
    "Move the 'COMPILED-FILE' to 'me/config-elisp-file' and ensure
  it is byte-compiled."
    (unless (equal compiled-file me/config-org-file)
      (rename-file compiled-file me/config-elisp-file t))
    (byte-compile-file me/config-elisp-file))

  (defun me/compile-config-from-org-on-save ()
    "If the current buffer has 'me/config-org-file' open, compile
  the tangled elisp in the file, save it to 'me/config-elisp-file'
  and load it."
    (when (equal (file-truename (buffer-file-name))
                 (file-truename me/config-org-file))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
        (message "Compiling saved emacs config...")
        (me/compile-tangled-config
         (car (org-babel-tangle nil me/config-elisp-file "emacs-lisp")))
        (message "Reloading saved emacs config...")
        (load-file me/config-elisp-file))))

  (add-hook 'after-save-hook 'me/compile-config-from-org-on-save)
#+END_SRC

We also provide shortcut commands for reloading the config.

#+BEGIN_SRC emacs-lisp
  (defun compile-config ()
    "Recompile the config from 'me/config-org-file' into 'me/config-elisp-file'"
    (interactive)
    (me/compile-tangled-config
     (car (org-babel-tangle-file me/config-org-file me/config-elisp-file "emacs-lisp"))))

  (defun reload-config ()
    "Reload the config from 'me/config-org-file'"
    (interactive)
    (load-file me/config-elisp-file))

  (defun compile-and-reload-config ()
    "Recompile and reload the config from 'me/config-org-file'"
    (interactive)
    (compile-config)
    (reload-config))
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs.  It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself.  By default, changes in the customization will be
automatically detected and appended at the end of the configuration file.

Since, in this case, the configuration file is compiled by =org-mode=, the saved
changes would be easily overwritten.  Thus, we configure Emacs to save
configuration code in another file.  Ideally we would keep that file essentially
empty, incorporating any changes into the main configuration file and
documenting them.

#+BEGIN_SRC emacs-lisp
  (setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Load =.secret.el=

I use =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=.  This is also where you want your API tokens to live.

Note that the file will be loaded /after/ the complete configuration.

#+BEGIN_SRC emacs-lisp
  (defun me/load-secrets (loaded-file-name)
    (when (eq loaded-file-name me/config-elisp-file)
      (let ((secret-el (expand-file-name ".secret.el" user-emacs-directory)))
        (when (file-exists-p secret-el)
          (load secret-el)
          (message "Loaded .secret.el")))))

  (run-at-time "1 millisec" nil 'me/load-secrets me/config-elisp-file)
  (add-hook 'after-load-functions 'me/load-secrets)
#+END_SRC



* User Interface

A first important fix: for keyboard layouts with dead keys we need to load the following package.

#+BEGIN_SRC emacs-lisp
  (use-package iso-transl)
#+END_SRC

** Mode Line

The mode line can be made prettier (and easier to understand).

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (spaceline-emacs-theme)
    (spaceline-toggle-line-column-on)
    (spaceline-toggle-hud-on))
#+END_SRC

We can also improve how modes are displayed.

#+BEGIN_SRC emacs-lisp
  (use-package delight :ensure t)
#+END_SRC

** Colours and Fonts

The face for italic text is underlined when the font does not support
slant by default.  I don't like it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'italic nil :underline nil)
#+END_SRC

Load and set =dracula-theme=.

#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :ensure t :demand t
    :config
    (load-theme 'dracula t))
#+END_SRC

When running with a GUI, use the Fira Code font.  In order to simulate
its ligatures, we use the [[https://github.com/tonsky/FiraCode/wiki/Emacs-instructions][following workaround]].

#+BEGIN_SRC emacs-lisp
  (defvar me/fixed-width-font "Fira Code")

  (when (window-system)
    (set-frame-font me/fixed-width-font)

    (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
                   (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
                   (36 . ".\\(?:>\\)")
                   (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
                   (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                   (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
                   (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
                   (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                   (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
                   (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                   (48 . ".\\(?:x[a-zA-Z]\\)")
                   (58 . ".\\(?:::\\|[:=]\\)")
                   (59 . ".\\(?:;;\\|;\\)")
                   (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
                   (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                   (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                   (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
                   (91 . ".\\(?:]\\)")
                   (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                   (94 . ".\\(?:=\\)")
                   (119 . ".\\(?:ww\\)")
                   (123 . ".\\(?:-\\)")
                   (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                   (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
                   )
                 ))
      (dolist (char-regexp alist)
        (set-char-table-range composition-function-table (car char-regexp)
                              `([,(cdr char-regexp) 0 font-shape-gstring])))))
#+END_SRC
** Better Defaults

Some UI elements are rather invasive and require a mouse.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)                           ; Disable the cursor blinking
    (menu-bar-mode 0)                               ; Disable the menu bar
    (tool-bar-mode 0))                              ; Disable the tool bar
#+END_SRC

Here are some options that I consider better defaults.

#+BEGIN_SRC emacs-lisp
  (setq-default
   auto-window-vscroll nil                          ; Lighten vertical scroll
   confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   delete-by-moving-to-trash t                      ; Delete files to trash
   display-time-default-load-average nil            ; Don't display load average
   display-time-format nil                          ; Don't display the time
   fill-column 80                                   ; Set width for automatic line breaks
   help-window-select t                             ; Focus new help windows when opened
   indent-tabs-mode nil                             ; Stop using tabs to indent
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   left-margin-width 1 right-margin-width 1         ; Add left and right margins
   recenter-positions '(5 top bottom)               ; Set re-centering positions
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   scroll-margin 10                                 ; Add a margin when scrolling vertically
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   tab-width 4                                      ; Set width for tabs
   uniquify-buffer-name-style 'forward              ; Uniquify buffer names
   window-combination-resize t                      ; Resize windows proportionally
   x-stretch-cursor t)                              ; Stretch cursor to the glyph width
  (delete-selection-mode 1)                         ; Replace region when inserting text
  (display-time-mode 1)                             ; Enable time in the mode-line
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  (global-subword-mode 1)                           ; Iterate through CamelCase words
  (column-number-mode 1)                            ; Display column numbers in the status bar
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Editing Keybindings

I dislike the inconsistency between =C-w= in Emacs and bash.  Set =C-w= to
behave like bash, killing backward to the beginning of a word.  Also make =C-k=
kill the region, if active---otherwise the line is killed, as in the default
behaviour.  Note that some modes will have their own variants of =kill-line=
mapped to =C-k=, and those modes should call =me/bind-kill-region-or-line= in
their configuration.

#+BEGIN_SRC emacs-lisp
  (defmacro me/bind-kill-region-or-line (key-map kill-line kill-region)
    "Define and bind a function that kills the region, if active, or the line.
  The defined function will interactively call 'KILL-REGION' when
  the region is currently active, or 'KILL-LINE' otherwise.  It
  will also be bound to 'C-k' in the given 'KEY-MAP'."
    (let ((kill-region-or-line
           (intern (format "%s-or-%s" kill-region kill-line))))
      `(progn
         (defun ,kill-region-or-line ()
           ,(format
             "Kill the region if active, otherwise kill the current line.
  See also '%s' and '%s'."
             kill-region
             kill-line)
           (interactive)
           (if (region-active-p)
               (call-interactively ',kill-region)
             (call-interactively ',kill-line)))
         (define-key ,key-map (kbd "C-k") ',kill-region-or-line))))

  (global-set-key (kbd "C-w") 'backward-kill-word)
  (me/bind-kill-region-or-line global-map kill-line kill-region)
#+END_SRC

Undoing and redoing in Emacs is inconsistent with almost every other graphical
program.  Set =C-z= to undo and =C-S-z= to redo.  Also use the =undo-tree= mode
to have better handling of the undo history.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t :ensure t
    :delight undo-tree-mode nil
    :commands global-undo-tree-mode
    :bind
    (:map undo-tree-map
     ("C-_" . nil)
     ("C-/" . nil)
     ("C-?" . nil)
     ("M-_" . nil)
     ("C-z" . undo-tree-undo)
     ("C-S-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Better Completion and Search

Having a good completion mechanism can make life a lot easier.  The [[https://oremacs.com/swiper][=ivy=]]
package provides such a mechanism, which we couple with the fuzzy matching
provided by =flx=.

#+BEGIN_QUOTE
[[https://github.com/abo-abo/swiper/blob/master/README.md#ivy][abo-abo]]

Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

When running =ivy-mode=, pressing =<return>= will use the currently selected
candidate, while =C-<return>= will use the current input instead of the current
candidate.

#+BEGIN_SRC emacs-lisp
  (use-package flx :ensure t)

  (use-package ivy
    :ensure t
    :delight ivy-mode nil
    :commands ivy-mode ivy-resume ivy-immediate-done
    :config
    (ivy-mode 1)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy)))
    :custom-face
    (ivy-minibuffer-match-face-2 ((t (:background "#777777" :weight bold))))
    (ivy-minibuffer-match-face-3 ((t (:background "#777777" :weight bold))))
    (ivy-minibuffer-match-face-4 ((t (:background "#777777" :weight bold))))
    :bind
    (("C-c C-r" . 'ivy-resume)
     :map ivy-minibuffer-map
     ("C-<return>" . 'ivy-immediate-done)))
#+END_SRC

The =counsel= package provides ivy-based alternatives to some commonly used
builtin functionality, and =swiper= an alternative search command.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-x C-S-f" . 'counsel-recentf)
     ("<f1> f" . 'counsel-describe-function)
     ("<f1> v" . 'counsel-describe-variable)
     ("<f1> l" . 'counsel-find-library)
     ("<f2> i" . 'counsel-info-lookup-symbol)
     ("C-c u" . 'counsel-unicode-char)))

  (use-package swiper
    :ensure t
    :bind
    ("C-s" . 'swiper))
#+END_SRC

** Better Window Navigation

I like to navigate between windows with =C-x <arrow>=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x <left>") 'windmove-left)
  (global-set-key (kbd "C-x <right>") 'windmove-right)
  (global-set-key (kbd "C-x <down>") 'windmove-down)
  (global-set-key (kbd "C-x <up>") 'windmove-up)
#+END_SRC

I also disable the usual window navigation so I get used to arrows.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x o") nil)
#+END_SRC

** Auto-Completion

Auto-completion at point.  Display a small pop-in containing the candidates.
Use fuzzy matching provided by the =flx= package.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight company-mode nil
    :commands global-company-mode
    :config
    (setq-default
     company-idle-delay .2
     company-minimum-prefix-length 1
     company-require-match nil
     company-tooltip-align-annotations t))

  (use-package company-flx
    :ensure t
    :after company flx
    :delight company-flx-mode nil
    :commands company-flx-mode)

  (global-company-mode 1)
  (company-flx-mode 1)
#+END_SRC

** Recursive Minibuffers

   It should be possible to invoke mini minibuffer-based commands from within
   the minibuffer, keeping a stack of minibuffers.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

** Line Wrapping

When lines are too long, they will be soft-wrapped using =visual-line-mode=.
Since this mode ignores indentation, we use =adaptive-wrap= to correct it.

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
    :ensure t
    :commands adaptive-wrap-prefix-mode
    :hook
    ('visual-line-mode . 'adaptive-wrap-prefix-mode))

  (global-visual-line-mode 1)
#+END_SRC

** Removing Trailing Whitespace

By default, trailing whitespace is removed whenever a file is saved.  This can
be avoided by setting the file-local variable
=delete-trailing-whitespace-on-save= to =nil=.

#+BEGIN_SRC emacs-lisp
  (defvar delete-trailing-whitespace-on-save t
    "When non-nil, trailing whitespace is deleted before saving the file.")

  (make-variable-buffer-local 'delete-trailing-whitespace-on-save)

  (defun me/delete-trailing-whitespace-before-save ()
    "Remove trailing whitespace if 'remove-trailing-whitespace-on-save' is non-nil."
    (when delete-trailing-whitespace-on-save
      (delete-trailing-whitespace)))

  (add-hook 'before-save-hook 'me/delete-trailing-whitespace-before-save)
#+END_SRC

** Smart Handling of Parentheses

The [[https://github.com/Fuco1/smartparens][=smartparens=]] package makes it easier to deal with parentheses and
delimiters in general.  It will automatically insert the matching pair (e.g.,
when you type ='('=, it will insert =')'=), wrap the region inside parentheses,
among others.  Use the command =sp-cheat-sheet= to see the available commands
with examples.


#+BEGIN_SRC emacs-lisp
  (use-package smartparens-config
    :ensure smartparens   ; The package name differs from the provided feature
    :commands smartparens-mode)
#+END_SRC

The automatic use of =smartparens= should be ensured by setting up hooks for the
appropriate modes, under the appropriate entry of the [[Languages][Languages section]].

The =expand-region= package allows the region to be expanded according to delimiters.

#+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :ensure t
      :bind
      ("C-=" . er/expand-region))
#+END_SRC


The =rainbow-delimiters= package makes parentheses and brackets colorful, so it
is easier to find the matching ones.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t :defer t)
#+END_SRC



* Languages

** Emacs Lisp

Lisp should use the [[Smart Handling of Parentheses][=smartparens-mode=]].

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
#+END_SRC
