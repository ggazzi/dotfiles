#+TITLE: Emacs Configuration
#+AUTHOR: Guilherme Azzi

# Export all elisp snippets inside this file:
#+PROPERTY: header-args:emacs-lisp :tangle yes


* Table of Contents :TOC:
- [[#credits][Credits]]
- [[#initial-setup-and-compilation][Initial Setup and Compilation]]
  - [[#packaging-system][Packaging System]]
  - [[#compiling-the-configuration][Compiling the Configuration]]
  - [[#load-customel][Load =.custom.el=]]
  - [[#load-secretel][Load =.secret.el=]]
- [[#user-interface][User Interface]]
  - [[#mode-line][Mode Line]]
  - [[#colours-and-fonts][Colours and Fonts]]
  - [[#better-defaults][Better Defaults]]
  - [[#editing-keybindings][Editing Keybindings]]
  - [[#better-completion-and-search][Better Completion and Search]]
  - [[#better-window-navigation][Better Window Navigation]]
  - [[#auto-completion][Auto-Completion]]
  - [[#line-wrapping][Line Wrapping]]
  - [[#removing-trailing-whitespace][Removing Trailing Whitespace]]
  - [[#smart-handling-of-parentheses][Smart Handling of Parentheses]]
- [[#org-mode-and-getting-things-done][Org Mode and Getting Things Done]]
  - [[#org-mode][Org Mode]]
  - [[#gettings-things-done][Gettings Things Done]]
- [[#languages][Languages]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#latex][LaTeX]]
- [[#features][Features]]
  - [[#version-control][Version Control]]
  - [[#directory-browser][Directory Browser]]
  - [[#spell-and-grammar-checking][Spell and Grammar Checking]]
  - [[#shellbash][Shell/Bash]]
  - [[#on-the-fly-syntax-and-error-checking][On-The-Fly Syntax and Error Checking]]

* Credits

This configuration is heavily based on the work of others, in particular the following.

  - [[https://github.com/larstvei/dot-emacs]]


* Initial Setup and Compilation
** Packaging System

We initialize the packaging system, adding some common package
repositories.  Installed packages will /not/ be enabled by default.
Their loading will be described along the rest of this configuration.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC

We also ensure that the =use-package= macro is installed and loaded.
It provides many facilities for loading packages, including: loading
packages lazily, loading custom bits of configuration along with the
packages and auto-installing any missing packages.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))
#+END_SRC

This config file is written in =org-mode=, and should be stored in the
file =.emacs.d/config.dot=.

** Compiling the Configuration

Since the configuration is written in =org-mode= with tangled elisp
code, it must be compiled to an elisp file.  This compilation should
be done whenever this file is saved, which we guarantee with a custom
entry to =after-save-hook=.

#+BEGIN_SRC emacs-lisp
  (defvar me/config-org-file
    (expand-file-name "config.org" user-emacs-directory))

  (defvar me/config-elisp-file
    (expand-file-name "config.el" user-emacs-directory))

  (defun me/compile-tangled-config (compiled-file)
    "Move the 'COMPILED-FILE' to 'me/config-elisp-file' and ensure 
  it is byte-compiled."
    (unless (equal compiled-file me/config-org-file)
      (rename-file compiled-file me/config-elisp-file t))
    (byte-compile-file me/config-elisp-file))

  (defun me/compile-config-from-org-on-save ()
    "If the current buffer has 'me/config-org-file' open, compile
  the tangled elisp in the file, save it to 'me/config-elisp-file'
  and load it."
    (when (equal (buffer-file-name) me/config-org-file)
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
        (me/compile-tangled-config
         (car (org-babel-tangle nil me/config-elisp-file "emacs-lisp")))
        (load-file me/config-elisp-file))))

  (add-hook 'after-save-hook 'me/compile-config-from-org-on-save)
#+END_SRC

We also provide a shortcut command for reloading the config.

#+BEGIN_SRC emacs-lisp
  (defun reload-config ()
    "Recompile and reload the config from 'me/config-org-file'"
    (interactive)
    (me/compile-tangled-config
     (car (org-babel-tangle-file me/config-org-file me/config-elisp-file "emacs-lisp")))
    (load-file me/config-elisp-file))
#+END_SRC

** Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs.  It
is meant to help people who are not familiar with Emacs Lisp in the
configuration of Emacs itself.  By default, changes in the customization will be
automatically detected and appended at the end of the configuration file,
=init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up.  The
following tells Emacs to add extra code in another file that would be then
loaded, if existing.

#+BEGIN_SRC emacs-lisp
  (setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control.
For instance, you could set your identity by customizing both =user-full-name=
and =user-mail-address=.  This is also where you want your API tokens to live.

#+BEGIN_SRC emacs-lisp
  (let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))
#+END_SRC


* User Interface
** Mode Line

The mode line can be made prettier (and easier to understand).

#+BEGIN_SRC emacs-lisp
   (use-package powerline :ensure t
     :config
     (powerline-center-theme)
     (custom-set-variables
      '(powerline-default-separator 'slant)
      '(powerline-default-separator-dir (quote (left . right)))
      '(powerline-display-buffer-size nil))
     (custom-set-faces
      '(mode-line ((t (:background "grey18" :box (:line-width 1 :color "#44475a")))))
      '(mode-line-inactive ((t (:background "grey18" :foreground "#f8f8f2" :box (:line-width 1 :color "#373844")))))
      '(powerline-active1 ((t (:background "#cc863d" :foreground "grey15"))))
      '(powerline-active2 ((t (:background "#cc863d" :foreground "grey15"))))
      '(powerline-inactive1 ((t (:background "grey25"))))
      '(powerline-inactive2 ((t (:background "grey25" :foreground "#f8f8f2"))))))
#+END_SRC

We can also improve how modes are displayed.

#+BEGIN_SRC emacs-lisp
  (use-package delight :ensure t)
#+END_SRC

** Colours and Fonts

The face for italic text is underlined when the font does not support
slant by default.  I don't like it.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'italic nil :underline nil)
#+END_SRC

Load =afternoon-theme=.

#+BEGIN_SRC emacs-lisp
  (use-package dracula-theme
    :ensure t
    :demand t
    :config
    (load-theme 'dracula t))
#+END_SRC

When running with a GUI, use the Fira Code font.  In order to simulate
its ligatures, we use the [[https://github.com/tonsky/FiraCode/wiki/Emacs-instructions][following workaround]].

#+BEGIN_SRC emacs-lisp
  (when (window-system) (set-frame-font "Fira Code"))

  (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
		 (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
		 (36 . ".\\(?:>\\)")
		 (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
		 (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
		 (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
		 (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
		 (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
		 (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
		 (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
		 (48 . ".\\(?:x[a-zA-Z]\\)")
		 (58 . ".\\(?:::\\|[:=]\\)")
		 (59 . ".\\(?:;;\\|;\\)")
		 (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
		 (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
		 (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
		 (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
		 (91 . ".\\(?:]\\)")
		 (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
		 (94 . ".\\(?:=\\)")
		 (119 . ".\\(?:ww\\)")
		 (123 . ".\\(?:-\\)")
		 (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
		 (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
		 )
	       ))
    (dolist (char-regexp alist)
      (set-char-table-range composition-function-table (car char-regexp)
			    `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+END_SRC

** Better Defaults

Some UI elements are rather invasive and require a mouse.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)                           ; Disable the cursor blinking
    (menu-bar-mode 0)                               ; Disable the menu bar
    (tool-bar-mode 0))                              ; Disable the tool bar
#+END_SRC

Here are some options that I consider better defaults.

#+BEGIN_SRC emacs-lisp
  (setq-default
   auto-window-vscroll nil                          ; Lighten vertical scroll
   confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   delete-by-moving-to-trash t                      ; Delete files to trash
   display-time-default-load-average nil            ; Don't display load average
   display-time-format "%H:%M"                      ; Format the time string
   fill-column 80                                   ; Set width for automatic line breaks
   help-window-select t                             ; Focus new help windows when opened
   indent-tabs-mode nil                             ; Stop using tabs to indent
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   left-margin-width 1 right-margin-width 1         ; Add left and right margins
  ; mouse-yank-at-point t                            ; Yank at point rather than pointer
  ; ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
   recenter-positions '(5 top bottom)               ; Set re-centering positions
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   scroll-margin 10                                 ; Add a margin when scrolling vertically
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   tab-width 4                                      ; Set width for tabs
   uniquify-buffer-name-style 'forward              ; Uniquify buffer names
   window-combination-resize t                      ; Resize windows proportionally
   x-stretch-cursor t)                              ; Stretch cursor to the glyph width
  (delete-selection-mode 1)                         ; Replace region when inserting text
  (display-time-mode 1)                             ; Enable time in the mode-line
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  (global-subword-mode 1)                           ; Iterate through CamelCase words
  (fringe-mode 0)                                   ; Disable fringes
  (global-display-line-numbers-mode 1)              ; Display line numbers beside text
  (line-number-mode 0)                              ; Omit line numbers in the status bar
  (column-number-mode 1)                            ; Display column numbers in the status bar
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Editing Keybindings

I dislike the inconsistency between =C-w= in Emacs and bash.  Set =C-w= to
behave like bash, killing backward to the beginning of a word.  Also make =C-k=
kill the region, if active---otherwise the line is killed, as in the default
behaviour.

#+BEGIN_SRC emacs-lisp
  (defun kill-region-or-line ()
    "Kill the region if active, otherwise kill the current line.

  See also 'kill-region' and 'kill-line'."
    (interactive)
    (if (region-active-p)
        (call-interactively 'kill-region)
      (call-interactively 'kill-line)))

  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "C-k") 'kill-region-or-line)
#+END_SRC

Undoing and redoing in Emacs is inconsistent with almost everything else.  Set
=C-z= to undo and =C-S-z= to redo.  Also use the =undo-tree= mode to have better
handling of the undo history.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t
    :ensure t
    :delight undo-tree-mode nil
    :bind
    (:map undo-tree-map
          ("C-_" . nil)
          ("C-/" . nil)
          ("C-?" . nil)
          ("M-_" . nil)
          ("C-z" . undo-tree-undo)
          ("C-S-z" . undo-tree-redo))
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Better Completion and Search

Having a good completion mechanism can make life a lot easier.  The [[https://oremacs.com/swiper][=ivy=]]
package provides such a mechanism, which we couple with the fuzzy matching
provided by =flx=.  The =counsel= package provides ivy-based alternatives to
some commonly used builtin functionality, and =swiper= an alternative search.

#+BEGIN_QUOTE
[[https://github.com/abo-abo/swiper/blob/master/README.md#ivy][abo-abo]]

Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.
#+END_QUOTE

When running =ivy-mode=, pressing =enter= will use the currently selected
candidate, while =C-enter= will use the current input instead of the current
candidate.

#+BEGIN_SRC emacs-lisp
  (use-package flx :ensure t)

  (use-package ivy
    :ensure t
    :delight ivy-mode nil
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy)))
    (custom-set-faces
     '(ivy-minibuffer-match-face-2 ((t (:background "#777777" :weight bold))))
     '(ivy-minibuffer-match-face-3 ((t (:background "#777777" :weight bold))))
     '(ivy-minibuffer-match-face-4 ((t (:background "#777777" :weight bold)))))
    :bind
    ((:map global-map
           ("C-c C-r" . 'ivy-resume))
     (:map ivy-mode-map
           ("C-<return>" . 'ivy-immediate-done))))

  (use-package counsel
    :ensure t
    :bind
    (:map global-map
          ("M-x" . 'counsel-M-x)
          ("C-x C-f" . 'counsel-find-file)
          ("<f1> f" . 'counsel-describe-function)
          ("<f1> v" . 'counsel-describe-variable)
          ("<f1> l" . 'counsel-find-library)
          ("<f2> i" . 'counsel-info-lookup-symbol)
          ("C-c u" . 'counsel-unicode-char)))

  (use-package swiper
    :ensure t
    :bind
    (:map global-map
          ("C-s" . 'swiper)))
#+END_SRC

** Better Window Navigation

I like to navigate between windows with =C-x <arrow>=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x <left>") 'windmove-left)
  (global-set-key (kbd "C-x <right>") 'windmove-right)
  (global-set-key (kbd "C-x <down>") 'windmove-down)
  (global-set-key (kbd "C-x <up>") 'windmove-up)
#+END_SRC

I also disable the usual window navigation so I get used to arrows.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x o") nil)
#+END_SRC

** Auto-Completion

Auto-completion at point.  Display a small pop-in containing the candidates.
Use fuzzy matching provided by the =flx= package.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :defer 1
    :delight company-mode nil
    :config
    (global-company-mode 1)
    (setq-default
     company-idle-delay .2
     company-minimum-prefix-length 1
     company-require-match nil
     company-tooltip-align-annotations t))

  (use-package flx :ensure t :defer 1)

  (use-package company-flx
    :ensure t
    :defer 1
    :after company flx
    :delight company-flx-mode nil
    :config
    (company-flx-mode 1))
#+END_SRC

** Line Wrapping

When lines are too long, they are often soft-wrapped.  In order to correct their
indentation, we use =adaptive-wrap=.

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
    :ensure t
    :hook
    ('visual-line-mode-hook . 'adaptive-wrap-prefix-mode)
    :config
    (global-visual-line-mode 1))
#+END_SRC
** Removing Trailing Whitespace

By default, trailing whitespace is removed whenever a file is saved.  This can
be avoided by setting the file-local variable
=remove-trailing-whitespace-on-save= to =nil=.

#+BEGIN_SRC emacs-lisp
  (defvar remove-trailing-whitespace-on-save t
    "When non-nil, trailing whitespace is removed before saving the file.")

  (make-variable-buffer-local 'remove-trailing-whitespace-on-save)

  (defun me/remove-trailing-whitespace-before-save ()
    "Remove trailing whitespace if 'remove-trailing-whitespace-on-save' is non-nil."
    (when remove-trailing-whitespace-on-save
      (remove-trailing-whitespace)))

  (add-hook 'before-save-hook 'me/remove-trailing-whitespace-before-save)
#+END_SRC
** Smart Handling of Parentheses

The [[https://github.com/Fuco1/smartparens][=smartparens=]] package makes it easier to deal with parentheses and
delimiters in general.  It will automatically insert the matching pair (e.g.,
when you type ='('=, it will insert =')'=), wrap the region inside parentheses,
among others.  Use the command =sp-cheat-sheet= to see the available commands
with examples.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens-config
    :ensure smartparens
    :defer t)
#+END_SRC

The automatic use of =smartparens= should be ensured by setting up hooks for the
appropriate modes, under the appropriate entry of the [[Languages][Languages section]].


* Org Mode and Getting Things Done
** Org Mode

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :delight org-mode "Org"
    :preface
    (defun me/org-src-buffer-name (org-buffer-name language)
      "Construct the buffer name for a source editing buffer. See
  `org-src--construct-edit-buffer-name'."
      (format "*%s*" org-buffer-name))
    (defun org-kill-region-or-line ()
      "Kill the region if active, otherwise kill the current line

  See also 'kill-region' and 'org-kill-line'."
      (interactive)
      (if (region-active-p)
          (call-interactively 'kill-region)
        (call-interactively 'org-kill-line)))
    :hook
    ((org-mode . org-sticky-header-mode)
     (org-mode . toc-org-enable)
     (org-mode . flyspell-mode))
    :bind
    (:map org-mode-map
          ("C-k" . 'org-kill-region-or-line))
    :config
    (setq
     org-support-shift-select nil
     org-startup-truncated nil
     org-log-done 'time
     org-hide-leading-stars t
     org-return-follows-link t
     org-enforce-todo-dependencies t
     org-ellipsis "â¤µ")
    (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer-name))
#+END_SRC

Display in the header-line the heading of the node at the top of the window.
This avoids confusion when there is some text at the top of the window, and its
heading wouldn't be visible.

#+BEGIN_SRC emacs-lisp
  (use-package org-sticky-header
    :ensure t
    :config
    (setq-default
     org-sticky-header-full-path 'full
     org-sticky-header-outline-path-separator " / "))
#+END_SRC

Tired of having to manually update your tables of contents?  This
package will maintain a TOC at the first heading that has a =:TOC:=
tag.

#+BEGIN_SRC emacs-lisp
  (use-package toc-org :ensure t :after org)
#+END_SRC

We can make =org-mode= prettier by showing actual bullets.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :after org
    :delight org-bullets-mode nil
    :config
    (add-hook 'org-mode-hook
              (lambda () (org-bullets-mode 1))))
#+END_SRC

** Gettings Things Done

I am trying to adopt GTD, implemented using org-mode and following
some workflows suggested [[https://orgmode.org/worg/org-gtd-etc.html][online]].

*** File Structure

Most of the files related to GTD are kept in the directory =~/gtd=,
which includes the following.

 - =inbox.org= contains [[Capture][captured]] stuff to process later;
 - =projects.org= contains the current projects;
 - =someday.org= contains ideas and tasks for the future that should
   be periodically checked, but not all the time.
 - =tickler.org= contains entries that should be seen at a particular
   point in the future, recorded as a [[orgmode.org/manual/Timestamps.html][timestamp]].
 - =references= contains reference documents, to which projects should
   link using =org-store-link= from Dired buffers.
 - =*.org_archive= files contain done projects, tasks and other items
   that need no longer be reviewed.

#+BEGIN_SRC emacs-lisp
  (defvar me/gtd-directory "~/gtd"
    "Root directory where the GTD files are located")

  (defvar me/gtd-inbox-file (expand-file-name "inbox.org" me/gtd-directory)
    "Org file where new tasks and ideas are collected")

  (defvar me/gtd-projects-file (expand-file-name "projects.org" me/gtd-directory)
    "Org file where projects are listed and planned")

  (defvar me/gtd-someday-file (expand-file-name "someday.org" me/gtd-directory)
    "Org file for suspended ideas and tasks")

  (defvar me/gtd-tickler-file (expand-file-name "tickler.org" me/gtd-directory)
    "Org file where reminders are set for particular points in the future")
#+END_SRC


*** Steps
**** Capture

The first part of the GTD system is capturing /everything/---every
thought, task, idea---into an inbox to be later processed.  Adding a
new entry to the inbox should be super easy and frictionless, so there
is no incentive to avoid it, and it also doesn't interrupt the task at
hand.

In Emacs this we use the [[https://orgmode.org/manual/Capture.html][capture]] feature of =org-mode=, which can be
activated with =C-c c=, to add entries to =inbox.org=.  There may be
other inboxes in one's life: e-mail, messaging apps, a physical
inbox...

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat me/gtd-directory "/inbox.org"))
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

You can add links to the captured entries with =C-c C-l=, which make it easier
to access related material.  If you are linking to something that was accessed
inside Emacs, you can use =C-c l= to copy a link to its location, then =C-c C-l=
to paste it.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-l") 'org-store-link)
#+END_SRC

In particular we set up some templates for easily adding a new task or
a new reminder for a particular point in the future.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
	'(("t" "To-do [inbox]" entry
	   (file+headline me/gtd-inbox-file "Tasks")
	   "* TODO %i%?")
	  ("n" "Note [inbox]" entry
	   (file+headline me/gtd-inbox-file "Notes"))
	  ("r" "Reminder" entry
	   (file+headline me/gtd-ticker-file "Tickler")
	   "* %i%? \n %U")))
#+END_SRC

**** Clarify and Organize

Every inbox should be periodically checked.  The meaning of each entry
should be checked, and it should either be solved or moved to the
appropriate place, according to the standard GTD workflow:

[[https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/GTDcanonical.png/1280px-GTDcanonical.png]]

In order to easily move entries from the =inbox.org= to the
appropriate place, we can [[https://orgmode.org/manual/Refile-and-copy.html#Refile-and-copy][refile]] entries with =C-c C-w=.  Common
targets include any project, the tickler or the someday/maybe list.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
	'((me/gtd-projects-file :maxlevel . 3)
	  (me/gtd-someday-file :maxlevel . 2)
	  (me/gtd-tickler-file :maxlevel . 2)))
#+END_SRC

Tasks may be in one of the following states.
  - =NEXT=: incomplete and should be done in the near future
  - =TODO=: incomplete, but need not be done in the near future
  - =WAITING=: incomplete, but there's nothing to be done for now
  - =DONE=: completed succesfully
  - =CANCELLED=: no longer relevant

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"
           "NEXT(n)"
           "WAITING(w)"
           "|"
           "DONE(d)"
           "CANCELLED(c)")))
#+END_SRC

When filing tasks and other notes, they can be annotated with tags,
which may denote a few different things.

 - Regular categories, like =:work:= or =:health:=
 - People involved in the task, like =:dad:= or =:sabine:=
 - GTD contexts starting with an =@=, such as =@home=, =@office=,
   =@phone=, =@email=, =@errands=, =@laptop=.

Tasks and notes can also [[orgmode.org/manual/Deadlines-and-scheduling.html][be scheduled or have deadlines]], including
repeating schedules and items.  You should avoid adding dates to
anything that isn't an appointment, a hard deadline or a tickler
entry.  The decision of what to do next should be taken based on the
current context and next tasks, not based on artificial scheduling
decisions made with possibly outdated information.

**** Reflect

The lists should be reviewed frequently, which help keeps the big
picture of your life in your head.  Of course, reviewing every entry
of every list is quite time consuming, and shouldn't be done all the
time.  A good approach is reviewing all lists once a week---the
so-called weekly review.  When deciding what to do next, you should
first review your calendar/agenda to check appointments and deadlines,
then check the =NEXT= actions, filtered by your current context.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
    (list
      me/gtd-projects-file
      me/gtd-inbox-file
      me/gtd-tickler-file))
 #+END_SRC

For day-to-day use of the GTD system, you should use both [[https://orgmode.org/manual/Sparse-trees.html][sparse trees]]
and [[https://orgmode.org/manual/Agenda-views.html#Agenda-views][agenda views]].  Each Org document can be turned into a sparse tree
with =C-c /=, which will use some dispatcher to show little, selected
information about each item in the document.

In order to easily open the GTD files, we provide the following commands.

#+BEGIN_SRC emacs-lisp
  (defun open-gtd-inbox ()
    (interactive)
    (find-file me/gtd-inbox-file))

  (defun open-gtd-projects ()
    (interactive)
    (find-file me/gtd-projects-file))

  (defun open-gtd-tickler ()
    (interactive)
    (find-file me/gtd-tickler-file))

  (defun open-gtd-someday ()
    (interactive)
    (find-file me/gtd-someday-file))
#+END_SRC

[[https://orgmode.org/manual/Agenda-views.html#Agenda-views][Agenda views]] provide a summarized overview of the calendar/agenda and
pending tasks from multiple files.  [[orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][Custom agenda commands]] can be
defined to, e.g., show only the next actions, filter them by context.

I use =C-c a= to access the agenda dispatcher, which then allows me to choose
among the many agenda views.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

**** Engage

Do stuff!  Complete the next actions!


* Languages
** Emacs Lisp

Lisp should use the [[Smart Handling of Parentheses][=smartparens-mode=]].

#+BEGIN_SRC emacs-lisp
  (add-hook 'elisp-mode 'smartparens-mode)
#+END_SRC

** LaTeX

Note that the =auctex= tool must be installed externally for this to work.  Some
options are modified, such as a compilation to PDF by default.  Since I often
split LaTeX projects into multiple files, I also force =TeX-mode= to always ask
for a master file by setting =TeX-master=.  I also add support for using a
=Makefile= to compile LaTeX projects.

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :defer t
    :ensure auctex
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-PDF-mode t)
    (setq-default TeX-master nil)
    (add-to-list 'TeX-command-list
                 '("Make" "make" TeX-run-compile nil t)))
#+END_SRC

When using =LaTeX-mode=, we want to automatically turn on the following
features: [[Spell and Grammar Checking][spell checking]], [[Smart Handling of Parentheses][smart parentheses]], synchronisation of the point with
the document viewer (=TeX-source-correlate-mode=), easy insertion of
mathematical symbols (=LaTeX-math-mode=) and easier management of labels,
references and citations (=reftex-mode=).

Moreover, a compilation error overview should be available with =C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (use-package latex
    :defer t
    :after tex
;    :config
;    (use-package preview-latex)
    :bind
    (:map LaTeX-mode-map
          ("C-c C-o" . TeX-error-overview))
    :hook
    ((LaTeX-mode-hook . flyspell-mode)
     (LaTeX-mode-hook . smartparens-mode)
     (LaTeX-mode-hook . LaTeX-math-mode)
     (LaTeX-mode-hook . TeX-source-correlate-mode)
     (LaTeX-mode-hook . reftex-mode)))
#+END_SRC

We also enable auto-completion of bibtex keys using [[https://github.com/gbgar/company-bibtex][=company-bibtex=]].  Its
completion function has to be modified to allow for fuzzy matching, and to show
more readable annotations.

#+BEGIN_SRC emacs-lisp
  (use-package company-bibtex
    :ensure t
    :after latex
    :preface
    (defun me/company-bibtex (command &optional arg &rest ignored)
      "`company-mode' completion backend for bibtex key completion.
  This backend activates for citation styles used by `pandoc-mode' (@),
  `latex-mode' (\cite{}), and `org-mode' (ebib:), and reads from a
  bibliography file or files specified in `company-bibtex-bibliography'.
  COMMAND, ARG, and IGNORED are used by `company-mode'."

      (interactive (list 'interactive))
      (cl-case command
        (interactive (company-begin-backend 'company-bibtex))
        (prefix (cond ((derived-mode-p 'latex-mode)
                       (company-grab (format "%s\\(%s,\\)*\\(%s\\)"
                                             company-bibtex-latex-citation-regex
                                             company-bibtex-key-regex
                                             company-bibtex-key-regex)
                                     2))
                      ((derived-mode-p 'org-mode)
                       (company-grab (format "%s\\(%s,\\)*\\(%s\\)"
                                             company-bibtex-org-citation-regex
                                             company-bibtex-key-regex
                                             company-bibtex-key-regex)
                                     2))
                      ((derived-mode-p 'markdown-mode)
                       (company-grab (format "%s\\(%s\\)"
                                             company-bibtex-pandoc-citation-regex
                                             company-bibtex-key-regex)
                                     1))
                      ))
        (candidates (company-bibtex-candidates arg))
        (annotation (me/company-bibtex-get-annotation arg))
        (meta (me/company-bibtex-get-metadata arg))
        (duplicates t)
        (no-cache t)))

    (defun me/company-bibtex-get-annotation (candidate)
      "Get annotation from CANDIDATE, which is its title."
      (let ((prefix-length 0))
        (format " | %s"
                (replace-regexp-in-string "{\\|}" ""
                                          (get-text-property prefix-length :title candidate)))))

    (defun me/company-bibtex-get-metadata (candidate)
      "Get metadata from CANDIDATE."
      (let ((prefix-length 0))
        (replace-regexp-in-string "{\\|}" ""
                                  (format "Title: %s\nAuthors: %s"
                                          (get-text-property prefix-length :title candidate)
                                          (replace-regexp-in-string "[[:space:]]*\n[[:space:]]*" " "
                                                                    (get-text-property prefix-length :author candidate))))))
    :config
    (add-to-list 'company-backends 'company-bibtex)
    (defalias 'company-bibtex 'me/company-bibtex))
#+END_SRC


* Features
** Version Control

[[https://magit.vc/][Magit]] provides git facilities directily withing Emacs.  It is honestly the best
git frontend I have ever used.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Jonas Bernoulli]]

Magit is an interface to the version control system [[https://git-scm.com/][Git]], implemented as an [[https://www.gnu.org/software/emacs][Emacs]]
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.
[[https://magit.vc/about.html][(more)]]
#+END_QUOTE

The magit status buffer can be opened with =C-x g=.  Most of the functionality
of magit is available from there, as documented in the [[https://magit.vc/manual/magit.html#Getting-Started][magit manual]].

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (:map global-map
          ("C-x g" . 'magit-status))
    :config
    (setq magit-completing-read-function 'ivy-completing-read))
#+END_SRC
** Directory Browser

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :bind
    (:map dired-mode-map
          ;; Avoid opening too many dired buffers
          ("<return>" . 'dired-find-alternate-file)
          ("C-<return>" . 'dired-find-file))
    :hook (dired-mode-hook . dired-hide-details-mode)
    :config
    (setq
     dired-auto-revert-buffer t
     dired-dwim-target t
     dired-hide-details-hide-symlink-targets nil
     dired-listing-switches "-alh --group-directories-first"
     dired-ls-F-marks-symlinks nil
     dired-recursive-copies 'always))
#+END_SRC
** Spell and Grammar Checking

Commands related to spell and grammar checking are prefixed with =C-S-l=.

The underlying spell checker is preferably Aspell, but alternatively Hunspell.
Note that Aspell personal dictionaries are stored in =~/.aspell.LANG.pws=, where
=LANG= is the two-letter code.  I use British English most of the time.

#+BEGIN_SRC emacs-lisp
  (cond
   ((executable-find "aspell")
    (setq ispell-program-name "aspell"))
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")))

  (setq ispell-dictionary "en_GB")
#+END_SRC

The =flyspell-mode= will highlight misspelled words.  Then =C-S-l c= can be used
to correct them.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :bind
    (:map flyspell-mode-map
          ("C-S-l c" . 'ispell-word))
    :hook (text-mode-hook . flyspell-mode))
#+END_SRC

Besides spell checking, [[https://languagetool.org/][languagetool]] can be used to check grammar.  It is
enabled for the current buffer with =C-S-l e= and disabled with =C-S-l d=.

#+BEGIN_SRC emacs-lisp
  (use-package langtool
    :ensure t
    :defer t
    :bind
    (:map global-map
      ("C-S-l e" . langtool-check)
      ("C-S-l d" . langtool-check-done))
    :config
    (setq langtool-bin "/bin/languagetool")
    (setq langtool-language-tool-jar "/usr/share/java/languagetool/languagetool.jar")
    (setq langtool-mother-tongue "pt-BR"))
#+END_SRC
** Shell/Bash

A bash shell can be run inside Emacs with the =ansi-term= command.  A shortcut
for opening a bash is =C-x t=.

#+BEGIN_SRC emacs-lisp
  (defun term-bash ()
    (interactive)
    (ansi-term "bash"))

  (global-set-key (kbd "C-x t") 'term-bash)
#+END_SRC
